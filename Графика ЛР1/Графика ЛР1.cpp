#include <GL/glew.h> // Управляет расширениями OpenGL
#include <GL/freeglut.h>
#include <stdio.h> // Для вывода ошибки
#include "math_3d.h" // Для Vector3f

GLuint VBO; // Указатель на буфер вершин (в нашем случае точек)

void RenderScene()
{
	// Очистка буфера кадра, использует указанный заранее цвет (glClearColor(0.0f, 0.0f, 0.0f, 0.0f);)
	glClear(GL_COLOR_BUFFER_BIT);

	// Координаты вершин, используемые в буфере, рассматриваются как атрибут вершины с индексом 0
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ARRAY_BUFFER, VBO); // Обратно привязыевам буффер VBO

	// Указывает как воспринимать данные внутри буффера. Параметры:
	// 1 - указывает на индекс атрибута, 2 - кол-во компонентов в атрибуте (3 - x, y, z)
	// 3 - тип данных для каждого компонента, 4 - хотим ли нормализовать атрибуты перед конвейром
	// 5 - шаг - число байт между 2 экземплярами атрибута (в нашем случа буфер хранит только координаты вершин)
	// 6 - смещение в структуре, которое получит наш конвейер
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);

	// Функция порядковой (буфера индексов) отрисовки
	// Параметры: 1 - тип объекта
	// 2 - первый индекс для отрисовки (тут начало буфера)
	// 3 - кол-во вершин
	glDrawArrays(GL_TRIANGLES, 0, 3);

	// Отключение атрибутов вериш (хороший тон), без шейдеров - хороший способ получения проблем
	glDisableVertexAttribArray(0);

	// Меняет буферы фона и кадра местами
	glutSwapBuffers();
}

void CreateVertexBuffer()
{
	Vector3f Vertices[3]; // Массив точек (в данном случае одна)
	Vertices[0] = Vector3f(-0.5f, -0.5f, 0.0f); // Координаты точки (x, y, z)
	Vertices[1] = Vector3f(0.5f, -0.5f, 0.0f);
	Vertices[2] = Vector3f(0.0f, 0.5f, 0.0f);

	// Генерация объекта переменного типа
	glGenBuffers(1, &VBO); // 1 параметр - кол-во объектов, 2 - ссылка на массив указателей на буфер вершин

	// Привязыес указатель VBO к названию цели - GL_ARRAY_BUFFER, означающая, что буфер VBO будет хранить
	// Массив вершин
	glBindBuffer(GL_ARRAY_BUFFER, VBO);

	// Наполнение объекта (буфера) данными
	// 1 - название цели, 2 - размер данных в байтах, 3 - адрес массива вершин, 4 - флаг использования паттернов
	// GL_STATIC_DRAW - не собираемся изменять значения буффера
	glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);
}

int main(int argc, char** argv)
{
	/*--------------------------------------------------------------------------------------------------------*/
	// Инициализация GLUT
	// Параметры в функции:
	// в argv хранится значение, переданное через консоль
	// в argc - кол-во переданных значений
	glutInit(&argc, argv);

	// Настройка опций GLUT
	// GLUT_DOUBLE - двойная буферизация (1 буфер - отрисовка, фоновый буфер,
	// 2 буфер - отображение)
	// GLUT_RGBA - буфер цвета - для цвета на экране
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);

	// Настройка размера окна: ширина, высота
	glutInitWindowSize(612, 484);

	// Позиция создаваемого окна
	glutInitWindowPosition(100, 100);

	// Заголовок созданного окна
	glutCreateWindow("Main1");

	// Отдаём управление окном GLUT
	// glutDisplayFunc для взаимодействия с оконной системой
	// Для изменений в окне - функция обратного вызова (функция как параметр)
	glutDisplayFunc(RenderScene);
	/*--------------------------------------------------------------------------------------------------------*/

	// Проверка инициализации glew
	GLenum res = glewInit();
	if (res != GLEW_OK)
	{
		// Вывод ошибки, если инициализация провалилась
		fprintf(stderr, "Error: '%s'\n", glewGetErrorString(res));
		return -1;
	}

	// Установление состояний, устанавливает цвет
	// Используемый при очистке буфера кадра (красный, зел, синий, альфа канал)
	glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

	CreateVertexBuffer();

	// Цикл GLUT. Ждёт событий от экранной системы и передаёт их через
	// функцию обратного вызова
	glutMainLoop();

	return 0;
}